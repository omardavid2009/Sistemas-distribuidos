from flask import Flask, render_template, request, redirect, url_for, session, flash
import psycopg2
import requests

app = Flask(__name__)
app.secret_key = 'clave_super_secreta_dashboard'

# --- CONFIGURACIÓN DE IPs (¡CAMBIAR POR LAS TUYAS!) ---
IP_AUTH_SERVER = "10.61.157.246"  # Tu servidor de Login
IP_DB1 = "10.61.157.190"          # Nodo Shard 1 (Tecnología)
IP_DB2 = "10.61.157.191"          # Nodo Shard 2 (Hogar/Ropa)
IP_REPLICA = "10.61.157.200"      # Nodo de Respaldo (Copia todo)

# --- LÓGICA DE SHARDING (FRAGMENTACIÓN) ---
# Esta función decide a qué base de datos conectarse según la categoría
def get_db_connection(categoria):
    if categoria == 'Tecnologia':
        # Los productos de tecnología viven físicamente en el Servidor 1
        conn = psycopg2.connect(host=IP_DB1, user="admin", password="1234", database="tienda")
    else:
        # El resto (Hogar, Ropa, etc.) viven físicamente en el Servidor 2
        conn = psycopg2.connect(host=IP_DB2, user="admin", password="1234", database="tienda")
    return conn

# --- RUTAS DE LA APLICACIÓN ---

@app.route('/')
def index():
    if 'token' in session:
        return redirect(url_for('dashboard'))
    return render_template('login.html')

# Conexión con el Microservicio de Auth
@app.route('/login', methods=['POST'])
def login():
    username = request.form['username']
    password = request.form['password']
    try:
        # Hacemos una petición HTTP interna al contenedor de Auth
        response = requests.post(f"http://{IP_AUTH_SERVER}:5000/login", 
                                 json={'username': username, 'password': password})
        if response.status_code == 200:
            data = response.json()
            session['token'] = data['token']
            session['username'] = username
            return redirect(url_for('dashboard'))
        else:
            flash('Usuario o contraseña incorrectos')
            return redirect(url_for('index'))
    except Exception as e:
        flash(f'Error de conexión con Auth Server: {e}')
        return redirect(url_for('index'))

@app.route('/dashboard')
def dashboard():
    if 'token' not in session:
        return redirect(url_for('index'))
    
    productos_total = []
    
    # AGREGACIÓN DE DATOS: El Dashboard debe consultar TODOS los nodos para mostrar la lista completa
    # 1. Traer datos del Shard 1
    try:
        c1 = psycopg2.connect(host=IP_DB1, user="admin", password="1234", database="tienda")
        cur1 = c1.cursor()
        cur1.execute("SELECT * FROM productos")
        productos_total.extend(cur1.fetchall())
        c1.close()
    except: pass # Si un nodo falla, seguimos con el otro (Tolerancia a fallos parcial)

    # 2. Traer datos del Shard 2
    try:
        c2 = psycopg2.connect(host=IP_DB2, user="admin", password="1234", database="tienda")
        cur2 = c2.cursor()
        cur2.execute("SELECT * FROM productos")
        productos_total.extend(cur2.fetchall())
        c2.close()
    except: pass

    return render_template('dashboard.html', productos=productos_total, user=session['username'])

# --- CREAR PRODUCTO (SHARDING + REPLICACIÓN) ---
@app.route('/add_product', methods=['POST'])
def add_product():
    if 'token' not in session:
        return redirect(url_for('index'))
        
    nombre = request.form['nombre']
    categoria = request.form['categoria']
    precio = request.form['precio']
    
    sql = "INSERT INTO productos (nombre, categoria, precio) VALUES (%s, %s, %s)"
    datos = (nombre, categoria, precio)

    # PASO 1: Guardar en el Shard correcto (Distribución de carga)
    try:
        conn = get_db_connection(categoria)
        cur = conn.cursor()
        cur.execute(sql, datos)
        conn.commit()
        conn.close()
        flash(f'Producto guardado en nodo principal ({categoria}).')
    except Exception as e:
        flash(f'Error CRÍTICO en DB Principal: {e}')
        return redirect(url_for('dashboard'))

    # PASO 2: Replicación (Dual Write)
    # Escribimos el mismo dato en el servidor de respaldo
    try:
        conn_rep = psycopg2.connect(host=IP_REPLICA, user="admin", password="1234", database="tienda")
        cur_rep = conn_rep.cursor()
        cur_rep.execute(sql, datos)
        conn_rep.commit()
        conn_rep.close()
        print(f"--- [SYNC] Replicado exitosamente: {nombre} ---")
    except Exception as e:
        print(f"--- [ERROR] Falló la replicación: {e} ---")
        
    return redirect(url_for('dashboard'))

# --- BORRAR PRODUCTO (CONSISTENCIA DISTRIBUIDA) ---
@app.route('/delete/<string:categoria>/<int:id>')
def delete_product(categoria, id):
    if 'token' not in session:
        return redirect(url_for('index'))
    
    nombre_producto = None

    # 1. Borrar del Shard Principal
    try:
        conn = get_db_connection(categoria)
        cur = conn.cursor()
        # Primero obtenemos el nombre para poder borrarlo en la réplica (por si los IDs no coinciden)
        cur.execute("SELECT nombre FROM productos WHERE id = %s", (id,))
        res = cur.fetchone()
        if res: nombre_producto = res[0]
        
        cur.execute("DELETE FROM productos WHERE id = %s", (id,))
        conn.commit()
        conn.close()
        flash('Producto eliminado.')
    except Exception as e:
        flash(f'Error al eliminar: {e}')

    # 2. Borrar de la Réplica (Usando el nombre para asegurar consistencia)
    if nombre_producto:
        try:
            conn_rep = psycopg2.connect(host=IP_REPLICA, user="admin", password="1234", database="tienda")
            c_rep = conn_rep.cursor()
            c_rep.execute("DELETE FROM productos WHERE nombre = %s", (nombre_producto,))
            conn_rep.commit()
            conn_rep.close()
        except: pass
        
    return redirect(url_for('dashboard'))

# --- EDITAR PRODUCTO ---
@app.route('/edit/<string:categoria>/<int:id>', methods=['GET', 'POST'])
def edit_product(categoria, id):
    if 'token' not in session:
        return redirect(url_for('index'))
    
    conn = get_db_connection(categoria)
    cur = conn.cursor()

    if request.method == 'POST':
        # Actualizamos solo en el Shard principal (Simplificación para el proyecto)
        try:
            cur.execute("UPDATE productos SET nombre=%s, precio=%s WHERE id=%s",
                        (request.form['nombre'], request.form['precio'], id))
            conn.commit()
            conn.close()
            flash('Producto actualizado.')
            return redirect(url_for('dashboard'))
        except Exception as e:
            flash(f'Error: {e}')
    
    cur.execute("SELECT * FROM productos WHERE id = %s", (id,))
    producto = cur.fetchone()
    conn.close()
    return render_template('edit.html', producto=producto)

@app.route('/logout')
def logout():
    session.clear()
    return redirect(url_for('index'))

@app.route('/register', methods=['POST'])
def register():
    # Redirige la petición de registro al Auth Server
    try:
        requests.post(f"http://{IP_AUTH_SERVER}:5000/register", json=request.form)
        flash('Registro exitoso.')
    except:
        flash('Error en registro.')
    return redirect(url_for('index'))

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=80)
